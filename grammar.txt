
/****** Common definitions ******/
// TODO cleanup and make bindings consistent


/** Notes on types **/

_||_ : (Bool, Bool) -> Bool
_|_  : ({Type}A, {Type}B) -> (A + B)
// (Note that the | operator represents ordered choice.)

/** 1, 2, and 4 byte big-endian integers **/
byte       ::= 0..255
           >>= \x = Nat(x0)
two_octet  ::= byte byte
           >>= \x = x0<<8 + x1
four_octet ::= two_octet two_octet
           >>= \x = x0<<16 + x1

/** Old-style lengths **/
len_old1 ::= byte
         >>= \length = x0
len_old2 ::= two_octet
         >>= \length = x0
len_old4 ::= four_octet
         >>= \length = x0
// TODO indet

/** New-style (implicitly delimited) lengths **/
len_new1 ::= 0..192
         >>= \x = x0
len_new2 ::= 192..223 0..255
         >>= \length = (x0 - 192)<<8 + x1 + 192
len_new4 ::= 255 byte byte byte byte
         >>= \length = x1<<24 + x2<<16 + x3<<8 + x4
// TODO partial
len_new  ::= (len_new1 | len_new2 | len_new4)

/** Other common types **/
sha1_hash   ::= byte[20]
fingerprint ::= sha1_hash
timestamp   ::= four_octet


/****** Packet tags *****/

private0 ::= (0x00 len_old1 | 0x01 len_old2 | 0x02 len_old4
                | 0xc0 len_new)
               (private_body | invalid_tag_body)
pkesk ::= (0x04 len_old1 | 0x05 len_old2 | 0x06 len_old4
                | 0xc1 len_new)
               (pkesk_body | invalid_tag_body)
sig ::= (0x08 len_old1 | 0x09 len_old2 | 0x0a len_old4
                | 0xc2 len_new)
               (sig_body | invalid_tag_body)
skesk ::= (0x0c len_old1 | 0x0d len_old2 | 0x0e len_old4
                | 0xc3 len_new)
               (skesk_body | invalid_tag_body)
onepass_sig ::= (0x10 len_old1 | 0x11 len_old2 | 0x12 len_old4
                | 0xc4 len_new)
               (onepass_sig_body | invalid_tag_body)
secretkey ::= (0x14 len_old1 | 0x15 len_old2 | 0x16 len_old4
                | 0xc5 len_new)
               (secretkey_body | invalid_tag_body)
publickey ::= (0x18 len_old1 | 0x19 len_old2 | 0x1a len_old4
                | 0xc6 len_new)
               (publickey_body | invalid_tag_body)
secretsubkey ::= (0x1c len_old1 | 0x1d len_old2 | 0x1e len_old4
                | 0xc7 len_new)
               (secretsubkey_body | invalid_tag_body)
compressed ::= (0x20 len_old1 | 0x21 len_old2 | 0x22 len_old4
                | 0xc8 len_new)
               (compressed_body | invalid_tag_body)
sedp ::= (0x24 len_old1 | 0x25 len_old2 | 0x26 len_old4
                | 0xc9 len_new)
               (sedp_body | invalid_tag_body)
marker ::= (0x28 len_old1 | 0x29 len_old2 | 0x2a len_old4
                | 0xca len_new)
               (marker_body | invalid_tag_body)
literal ::= (0x2c len_old1 | 0x2d len_old2 | 0x2e len_old4
                | 0xcb len_new)
               (literal_body | invalid_tag_body)
trust ::= (0x30 len_old1 | 0x31 len_old2 | 0x32 len_old4
                | 0xcc len_new)
               (trust_body | invalid_tag_body)
userid ::= (0x34 len_old1 | 0x35 len_old2 | 0x36 len_old4
                | 0xcd len_new)
               (userid_body | invalid_tag_body)
publicsubkey ::= (0x38 len_old1 | 0x39 len_old2 | 0x3a len_old4
                | 0xce len_new)
               (publicsubkey_body | invalid_tag_body)
private15 ::= (0x3c len_old1 | 0x3d len_old2 | 0x3e len_old4
                | 0xcf len_new)
               (private_body | invalid_tag_body)
private16 ::= 0xd0 len_new (private_body | invalid_tag_body)
userattrib ::= 0xd1 len_new (userattrib_body | invalid_tag_body)
seipd ::= 0xd2 len_new (seipd_body | invalid_tag_body)
mdc ::= 0xd3 len_new (mdc_body | invalid_tag_body)
private20 ::= 0xd4 len_new (private_body | invalid_tag_body)
private21 ::= 0xd5 len_new (private_body | invalid_tag_body)
private22 ::= 0xd6 len_new (private_body | invalid_tag_body)
private23 ::= 0xd7 len_new (private_body | invalid_tag_body)
private24 ::= 0xd8 len_new (private_body | invalid_tag_body)
private25 ::= 0xd9 len_new (private_body | invalid_tag_body)
private26 ::= 0xda len_new (private_body | invalid_tag_body)
private27 ::= 0xdb len_new (private_body | invalid_tag_body)
private28 ::= 0xdc len_new (private_body | invalid_tag_body)
private29 ::= 0xdd len_new (private_body | invalid_tag_body)
private30 ::= 0xde len_new (private_body | invalid_tag_body)
private31 ::= 0xdf len_new (private_body | invalid_tag_body)
private32 ::= 0xe0 len_new (private_body | invalid_tag_body)
private33 ::= 0xe1 len_new (private_body | invalid_tag_body)
private34 ::= 0xe2 len_new (private_body | invalid_tag_body)
private35 ::= 0xe3 len_new (private_body | invalid_tag_body)
private36 ::= 0xe4 len_new (private_body | invalid_tag_body)
private37 ::= 0xe5 len_new (private_body | invalid_tag_body)
private38 ::= 0xe6 len_new (private_body | invalid_tag_body)
private39 ::= 0xe7 len_new (private_body | invalid_tag_body)
private40 ::= 0xe8 len_new (private_body | invalid_tag_body)
private41 ::= 0xe9 len_new (private_body | invalid_tag_body)
private42 ::= 0xea len_new (private_body | invalid_tag_body)
private43 ::= 0xeb len_new (private_body | invalid_tag_body)
private44 ::= 0xec len_new (private_body | invalid_tag_body)
private45 ::= 0xed len_new (private_body | invalid_tag_body)
private46 ::= 0xee len_new (private_body | invalid_tag_body)
private47 ::= 0xef len_new (private_body | invalid_tag_body)
private48 ::= 0xf0 len_new (private_body | invalid_tag_body)
private49 ::= 0xf1 len_new (private_body | invalid_tag_body)
private50 ::= 0xf2 len_new (private_body | invalid_tag_body)
private51 ::= 0xf3 len_new (private_body | invalid_tag_body)
private52 ::= 0xf4 len_new (private_body | invalid_tag_body)
private53 ::= 0xf5 len_new (private_body | invalid_tag_body)
private54 ::= 0xf6 len_new (private_body | invalid_tag_body)
private55 ::= 0xf7 len_new (private_body | invalid_tag_body)
private56 ::= 0xf8 len_new (private_body | invalid_tag_body)
private57 ::= 0xf9 len_new (private_body | invalid_tag_body)
private58 ::= 0xfa len_new (private_body | invalid_tag_body)
private59 ::= 0xfb len_new (private_body | invalid_tag_body)
private60 ::= 0xfc len_new (private_body | invalid_tag_body)
private61 ::= 0xfd len_new (private_body | invalid_tag_body)
private62 ::= 0xfe len_new (private_body | invalid_tag_body)
private63 ::= 0xff len_new (private_body | invalid_tag_body)

// An opaque, possibly valid private packet body
private_body ::= bytes[length]
// An opaque, invalid packet body
invalid_packet_body ::= bytes[length]

/****** Algorithms ******/


/**** Public-key algorithms ****/
// RFC 4880 s. 9.1

/** Prime-based crypto **/

// RSA
RSA_ES             ::= 1
algo_rsa_enc       ::= RSA_E=2 | RSA_ES
algo_rsa_sig       ::= RSA_S=3 | RSA_ES

// RSA predicates
// Other prime-based crypto
algo_elg_es        ::= ELG_ES=20
algo_elg_enc       ::= ELG_E=16
algo_dhx942_enc    ::= DH_X942=21

// Prime-based encryption
algo_prime_enc     ::= algo_elg_enc | algo_rsa_enc

// Prime-based signatures
algo_prime_sig     ::= algo_rsa_sig | algo_dsa | algo_elg_es

// Prime-based crypto predicates
let \is_rsae x       = (x == 2 || x == 1)
let \is_rsas x       = (x == 3 || x == 1)
let \is_rsa  x       = (x \in {1,2,3})
let \is_reserved x   = x == DH_X942
let \is_formerly x   = x == ELG_ES
let \is_deprecated x = x == RSA_ES

/** Elliptic-curve crypto **/
algo_ecdh          ::= ECDH=18
algo_ecdsa         ::= ECDSA=19

/** Unspecified crypto **/
PK_EXPERIMENTAL = 100..110
PK_UNKNOWN      = 4..15 | 22..99 | 111..255

let \algo_pk_shouldnt_process x = (   x \in PK_EXPERIMENTAL
                                   || x \in PK_UNKNOWN
                                   || x == ELG_ES)

/**** Symmetric-key algorithms ****/

// RFC 4880 s. 9.1, RFC 5581

algo_symm_plaintext ::= PLAINTEXT=0
// Algorithms with < 128-bit security strength
algo_symm_old       ::= IDEA=1 | TDES=2 | CAST5=3 | BLOWFISH=4
algo_symm_aes       ::= AES128=7 | AES192=8 | AES256=9
// Algorithms with >= 128-bit security strength
algo_symm_modern    ::= (algo_symm_aes
                         | TWOFISH=10
                         | CAMELLIA128=11 | CAMELLIA192=12 | CAMELLIA256=13)
SYMM_RESERVED       ::= 5 | 6
SYMM_PRIVATE        ::= 100..109
SYMM_UNDEFINED      ::= 14..99 | 111..255
algo_symm_other     ::= SYMM_RESERVED | SYMM_PRIVATE | SYMM_UNDEFINED
algo_symm           ::= algo_symm_modern | algo_symm_old | algo_symm_other

/**** Hash algorithms ****/

algo_hash_old      ::= MD5=1 | RIPEMD160=3
algo_hash_sha1     ::= SHA1=2
algo_hash_sha2_512 ::= SHA2_384=9 | SHA2_512=10
algo_hash_sha2     ::= SHA2_224=11 | SHA2_256=8 | algo_hash_sha2_512
HASH_RESERVED      ::= 4..7
HASH_PRIVATE       ::= 100..110
HASH_UNDEFINED     ::= 111..255
algo_hash_other    ::= HASH_RESERVED | HASH_PRIVATE | HASH_UNDEFINED
algo_hash          ::= algo_hash_old | algo_hash_sha1 | algo_hash_sha2 | algo_hash_other

/****** String-to-key (S2K) specifiers ******/
// RFC 4880 s. 3.7.1

/** Common definitions **/
s2k_salt          ::= bytes[8]

/**** S2K specifier types ****/

/** Undefined S2K specifiers **/
// These result in all following bytes becoming unparseable!
s2k_error         ::= (2 | 4..255) _=bytes*
/** Simple S2K (RFC 4880 s. 3.7.1.1) **/
s2k_simple        ::= S2K_SIMPLE=0x00   hash_algo
/** Salted S2K (RFC 4880 s. 3.7.1.2) **/
s2k_salted        ::= S2K_SALTED=0x01   hash_algo s2k_salt
/** Iterated and salted S2K (RFC 4880 s. 3.7.1.3) **/
s2k_encoded_count ::= c=byte
                  >>= \s2k_bytecount = (16 + (c&15)) << ((c>>4) + 6)
S2K_ITERATED = 0x03
s2k_iterated      ::= S2K_ITERATED=0x03 hash_algo s2k_salt s2k_encoded_count

/**** RFC 6637 EC private key S2K specifiers ****/
/** S2K specifier for EC private keys **/
// RFC 6637 s. 13
s2k_ec_128b       ::= s2k_iterated
/** S2K specifier for EC private keys at 192-bit security level **/
// RFC 6637 s. 12.2.1
// TODO: ????????
s2k_ec_192b       ::= S2K_ITERATED=0x03 hash_algo_sha2 s2k_salt s2k_encoded_count
// OR ??????
s2k_ec_192b       ::= S2K_ITERATED=0x03 hash_algo_sha2_512 s2k_salt s2k_encoded_count

/**** S2K specifiers, generally ****/
s2k_rfc4880       ::= s2k_error | s2k_simple | s2k_salted | s2k_iterated


/**** Various RFC 6637 internals ****/
// ECDH
ecdh_kdf_algo   ::= (SHA2_224 | SHA2_256 | SHA2_384 | SHA2_512)
ecdh_kek_algo   ::= (AES128 | AES192 | AES256)
ecdh_kdf_params ::= ecdh_hash_algo ecdh_symm_algo
pkesk_ecdh_asf  ::= PK_ECDH pkesk_ec_asf ecdh_kdf_params


/****** Public-key encrypted session key (tag 1) ******/
// RFC 4880 s. 

/** Prime based crypto **/
// RSA-E/RSA-ES
pkesk_rsa_asf         ::= algo_rsa_enc rsa_memodn:mpi
// ELG-E
pkesk_elge_asf        ::= algo_elg_enc elge_gkmodp:mpi elge_mykmodp:mpi
// X942DH????
// TODO: Any implementations of prime DH?

/** Elliptic curve crypto **/
// RFC 6637 s. 8
pkesk_ecdh_wrappedkey ::= wrappedkeylen:32..254 bytes[wrappedkeylen]
pkesk_ecdh_asf        ::= ec_ephem_pubkey:mpi pkesk_ecdh_wrappedkey

// Public-key encrypted session key
pkesk_v               ::= 3
pkesk_asf             ::= (pkesk_elge_asf | pkesk_rsa_asf | pkesk_ecdh_asf)
pkesk_body            ::= pkesk_v keyid pkesk_asf


/****** Signature (tag 2) ******/

/**** Signature types ****/
// RFC 4880 s. 5.2.1

SIG_V3 ::= (  SIG_BINARY         = 0x00
            | SIG_TEXT           = 0x01
            | SIG_GENERIC        = 0x10
            | SIG_PERSONA        = 0x11
            | SIG_CASUAL         = 0x12
            | SIG_POSITIVE       = 0x13
            | SIG_SUBKEYBIND     = 0x18
            | SIG_PRIMARYKEYBIND = 0x19
            | SIG_KEY            = 0x1f
            | SIG_REVOKE         = 0x20
            | SIG_SUBKEYREVOKE   = 0x28
            | SIG_CERTREVOKE     = 0x30
            | SIG_TIMESTAMP      = 0x40
            | SIG_THIRDPARTY     = 0x50 )
SIG_V4 ::= SIG_V3 | SIG_STANDALONE=0x02

sig_err_v3         ::= {SIG_V4}/{SIG_V3} error
sig_type_v3        ::= SIG_V3 | sig_type_unknown | sig_type_err_v3
sig_type_v4        ::= SIG_V4 | sig_type_unknown
sig_type_unknown   ::= (0x03..0x09 | 0x14..0x17 | 0x1a..0x1e | 0x21..0x27
                        | 0x29 | 0x31..0x39 | 0x41..0x49 | 0x51..0xff)

/**** Signature common definitions ****/
sig_creation_time  ::= timestamp
sig_signer_keyid   ::= keyid
sig_left2          ::= byte byte

/**** Algorithm specific fields ****/

/** Prime-based crypto algorithm-specific fields **/
// RFC 4880 s. 5.2.2
// RSA-S/RSA-ES
sig_asf_rsa        ::= &(is_rsas pubkey_algo_rsa) rsa_mdmodn:mpi
// DSA
sig_asf_dsa        ::= &pubkey_algo==DSA dsa_r:mpi dsa_s:mpi

/** Elliptic-curve crypto algorithm-specific fields **/
// RFC 6637 s. 10 (by reference to RFC 4880 5.2.2)
// ECDSA
sig_asf_ecdsa      ::= &pubkey_algo==ECDSA ecdsa_r:mpi ecdsa_s:mpi


/**** Signature v4 subpackets ****/
// TODO


/**** Signature v3 ****/
sig_asfs_v3        ::= sig_asf_rsa | sig_asf_dsa
sig_body_hashed_v3 ::= sig_type_v3 sig_creation_time
sig_body_v3        ::= 0x03
                       0x05
                       sig_body_hashed_v3
                       sig_signer_keyid:keyid
                       pubkey_algo
                       hash_algo
                       sig_asfs_v3

/**** Signature v4 ****/
sig_asfs_v4        ::= sig_asf_rsa | sig_asf_dsa | sig_asf_ecdsa
sig_body_v4        ::= 0x04
                       sig_type_v4
                       pubkey_algo
                       hash_algo
                       hashed_subpackets
                       unhashed_subpackets
                       sig_left2 sig_asfs_v4



/****** Symmetrically encrypted session key (tag 3) *******/
skesk_esk   ::= bytes[length - 3]
skesk_body  ::= 4 symm_algo s2k_spec skesk_esk



/****** One-pass signature (tag 4) ******/
onepass_sig_nested ::= 0x00|0x01
                   >>= \x = Bool(x)
onepass_sig_body ::= 0x03
                     sig_type_v4
                     hash_algo
                     pubkey_algo
                     onepass_sig_signer_keyid:keyid
                     onepass_sig_nested



/****** Public key packet formats ******/

/**** Public-key (tag 6) ****/
publickey_body    ::= pubkey
/**** Public-subkey (tag 14) ****/
publicsubkey_body ::= pubkey
/**** Secret-key (tag 5) ****/
secretkey_body    ::= pubkey secretkey
/**** Secret-subkey (tag 7) ****/
secretsubkey_body ::= pubkey secretkey


/**** Public key common definitions ****/

/**** Algorithm specific fields
rsa_n, rsa_e          = mpi, mpi
pubkey_asf_rsa_v3   ::= rsa_n rsa_e
pubkey_asf_rsa      ::= &(is_rsa pubkey_algo)

dsa_p, dsa_q, dsa_y   = mpi, mpi, mpi
pubkey_asf_dsa      ::= &pubkey_algo==DSA dsa_p:mpi dsa_q:mpi dsa_y:mpi

pubkey_asf_elg      ::= &pubkey_algo==ELG_E elg_p:mpi elg_q:mpi

//TODO ???????
pubkey_asf_ecdsa    ::= &pubkey_algo==ECDSA ecdsa_p:mpi ecdsa_q:mpi ecdsa_y:mpi

pubkey_asfs         ::= pubkey_asf_elg | pubkey_asf_dsa | pubkey_asf_rsa | pubkey_asf_ecdsa

/*** Public key version 3 ***/
let \creation_plus_days = IF x0!=0 | x1!=0
                          THEN (Nat(x0)<<8 + Nat(x1))*(24*3600)
                          ELSE Inf
pubkey_expiration_days ::= bytes bytes
                       >>= \pubkey_expiration_time = (creation_plus_days x0 x1) + pubkey_creation_time
pubkey_v3              ::= 0x03
                           pubkey_creation_time:timestamp
                           pubkey_expiration_days
                           pubkey_asf_rsa

/**** Public key version 4 ****/
pubkey_v4              ::= 0x04
                           pubkey_creation_time:timestamp
                           pubkey_algo
                           pubkey_asfs

/**** Secret keys ****/
// RFC 4880 s. 5.5.3

/** Secret key common definitions **/
seckey_enc_iv  ::= bytes[blocksize(symm_algo)]
s2k_convention_unencrypted ::= S2K_UNENCRYPTED=0
                           >>= \sumtype = ??
s2k_convention_encrypted   ::= (254 | 255) symm_algo s2k_spec seckey_enc_iv?
                           >>= \sumtype = IF 254 THEN "mdc" ELSE "cksum",
                               \enc = true
s2k_convention_otherenc    ::= symm_algo seckey_enc_iv?
                           >>= \sumtype = "cksum",
                               \enc = true, \hash_algo = MD5, \s2k_type = S2K_SIMPLE

// S2K checksum conventions
s2k_checksum   ::= &convention="cksum" cksum=two_octet
s2k_hash       ::= &convention="mdc" sha1_hash
s2k_sum        ::= s2k_checksum | s2k_hash | \epsilon

s2k_convention ::= (   S2K_UNENCRYPTED
                     | s2k_convention_encrypted
                     | s2k_convention_otherenc )
                   s2k_sum

/** Secret key algorithm-specific fields **/
// RSA_ES, RSA_E, RSA_S
seckey_asf_rsa ::= &(is_rsa pubkey_algo) rsa_d:mpi rsa_p:mpi rsa_q:mpi rsa_u:mpi
// DSA
seckey_asf_dsa ::= &pubkey_algo==DSA dsa_x:mpi
// ELG_E
seckey_asf_elg ::= &pubkey_algo==ELG_E elg_x:mpi

//TODO ECDH ECDSA

/** Secret keys **/
seckey_enckey  ::= &enc bytes*
seckey_asfs    ::= seckey_asf_rsa | seckey_asf_dsa | seckey_asf_elg
seckey_unencrypted ::= seckey_asfs (s2k_cksum | s2k_hash)
seckey         ::= s2k_convention  (seckey_enckey | seckey_unencrypted) nil


/****** Compressed data (tag 8) ******/
// RFC 4880 s. 5.6
compressed_data ::= bytes[length-1]
compressed_body ::= comp_algo compressed_data


/****** Symmetrically encrypted data packet (tag 9) ******/
// RFC 4880 s. 5.7
sedp_body       ::= bytes[length]


/****** Marker (tag 10) ******/
// RFC 4880 s. 5.8
marker_body     ::= "PGP"


/****** Literal (tag 11) ******/
// RFC 4880 s. 5.9
LITERAL_LOCAL = 'l' | '1'
// The compatibility predicate for 'local' format
let \islocal x = x \in {'l', '1'}
literal_format      ::= (  LITERAL_BINARY='b'
                         | LITERAL_TEXT='t'
                         | LITERAL_UTF8='u'
                         | literal_local )
literal_filenamelen ::= len_old1
literal_filename    ::= bytes[literal_filenamelen]
                    >>= \literal_datalen = length - 6 - literal_filenamelen
literal_date        ::= timestamp
literal_data        ::= (  &literal_format='b'       bytes[literal_datalen]
                         | &literal_format='t'       latin1_text[literal_datalen]
                         | &literal_format='u'       utf8_text[literal_datalen]
                         | &(islocal literal_format) local_text[literal_datalen])
literal_body        ::= literal_format literal_filenamelen literal_filename
                        literal_date literal_data


/****** Trust (tag 12) ******/
// RFC 4880 s. 5.10
trust_body          ::= bytes[length]


/****** User ID (tag 13) ******/
// RFC 4880 s. 5.11
userid_body         ::= utf8_text[length]


/****** User attribute (tag 17) ******/
// RFC 4880 s. 5.12
USERATTRIB_SUBPACKET_IMAGE = 1
USERATTRIB_SUBPACKET_EXPERIMENTAL = 100..110
USERATTRIB_SUBPACKET_IGNORED = 0 | 1..99 | 111..255
image_header_len           ::= byte byte
                           \x = x0 + x1<<8
IMAGE_FORMAT_JPEG            = 1
image_format               ::= IMAGE_FORMAT_JPEG | 100..110
image_header               ::= 0x10 0x00 0x01 image_format 0 0 0 0 0 0 0 0 0 0 0 0
userattrib_subpacket_image ::= image_header bytes[subpacketlen-20]
userattrib_subpacket_type  ::=   userattrib_subpacket_image
                               | USERATTRIB_SUBPACKET_EXPERIMENTAL
                               | USERATTRIB_SUBPACKET_IGNORED
userattrib_subpacket       ::= newlen userattrib_subpacket_type bytes[newlen]
                           >>= \data = x2, \type = x1, \subpacketlen = x0
userattrib_body            ::= userattrib_subpacket* nil


/****** Symmetrically encrypted integrity protected data (tag 18) ******/
// RFC 4880 s. 5.13
seipd_encdata ::= bytes[length-1]
seipd_body    ::= 1 seipd_encdata


/***** Modification detection code (tag 19) ******/
// RFC 4880 s. 5.14
mdc           ::= sha1_hash
mdc_body      ::= mdc


/****** ASCII Armor (RFC 4880 s. 6) ******/

/** ASCII Armor types **/
ascii_message ::= (  "PGP MESSAGE"
                   | "PGP PUBLIC KEY BLOCK"
                   | "PGP PRIVATE KEY BLOCK"
                   | "PGP MESSAGE, PART X/Y"
                   | "PGP SIGNATURE")

/** ASCII Armor common definitions **/
// TODO (additional semantic constraints) | "PGP MESSAGE, PART X"
armor_header_line ::= "-----BEGIN " ascii_message "-----\n"
                  >>= \message = ascii_message, \armor_keys = nil, \armor_values = nil
armor_tail_line   ::= "-----END " \message "-----\n"
armor_key_other   ::= latin1_text - {':'}
armor_key         ::= "Version" | "Comment" | "MessageID" | "Hash" | "Charset" | armor_key_other
armor_header      ::= armor_key ": " armor_value
                  >>= \armor_keys   = \armor_keys ++ [armor_key],
                      \armor_values = \armor_values ++ [armor_value]
blank_line        ::= whitespace* "\n"
base64_line       ::= base64[76] "\n"
last_base64       ::= base64[len] "="[padlen] &(padlen <= 3 && (len + padlen) <= 76)
armored_data      ::= base64_line* last_base64 "\n"
armor_checksum    ::= "=" base64[4] "\n"

/** ASCII Armor **/
ascii_armor   ::= armor_header_line
                  armor_header*
                  blank_line
                  armored_data
                  armor_checksum
                  armor_tail_line
